"use strict";
/*
 * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var net = require("net");
var tls = require("tls");
var Address = require("../Address");
var Promise = require("bluebird");
var BitsUtil_1 = require("../BitsUtil");
var LoggingService_1 = require("../logging/LoggingService");
var BuildMetadata_1 = require("../BuildMetadata");
var ClientConnection = /** @class */ (function () {
    function ClientConnection(connectionManager, address, clientNetworkConfig) {
        this.heartbeating = true;
        this.logging = LoggingService_1.LoggingService.getLoggingService();
        this.address = address;
        this.clientNetworkConfig = clientNetworkConfig;
        this.readBuffer = new Buffer(0);
        this.lastRead = 0;
        this.connectionManager = connectionManager;
        this.closedTime = 0;
        this.connectedServerVersionString = null;
        this.connectedServerVersion = BuildMetadata_1.BuildMetadata.UNKNOWN_VERSION_ID;
    }
    /**
     * Returns the address of local port that is associated with this connection.
     * @returns
     */
    ClientConnection.prototype.getLocalAddress = function () {
        return this.localAddress;
    };
    /**
     * Returns the address of remote node that is associated with this connection.
     * @returns
     */
    ClientConnection.prototype.getAddress = function () {
        return this.address;
    };
    /**
     * Connects to remote server and sets the hazelcast protocol.
     * @returns
     */
    ClientConnection.prototype.connect = function () {
        var _this = this;
        var ready = Promise.defer();
        var conCallback = function () {
            // Send the protocol version
            var buffer = new Buffer(3);
            buffer.write('CB2');
            _this.socket.write(buffer);
            ready.resolve(_this);
        };
        if (this.clientNetworkConfig.sslOptions) {
            var sslSocket = tls.connect(this.address.port, this.address.host, this.clientNetworkConfig.sslOptions, conCallback);
            this.localAddress = new Address(sslSocket.address().address, sslSocket.address().port);
            this.socket = sslSocket;
        }
        else {
            var netSocket = net.connect(this.address.port, this.address.host, conCallback);
            this.localAddress = new Address(netSocket.localAddress, netSocket.localPort);
            this.socket = netSocket;
        }
        this.socket.on('error', function (e) {
            _this.logging.warn('ClientConnection', 'Could not connect to address ' + _this.address.toString(), e);
            ready.reject(e);
            if (e.code === 'EPIPE' || e.code === 'ECONNRESET') {
                _this.connectionManager.destroyConnection(_this.address);
            }
        });
        return ready.promise;
    };
    ClientConnection.prototype.write = function (buffer) {
        var deferred = Promise.defer();
        try {
            this.socket.write(buffer, function (err) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    deferred.resolve();
                }
            });
        }
        catch (err) {
            deferred.reject(err);
        }
        return deferred.promise;
    };
    ClientConnection.prototype.setConnectedServerVersion = function (versionString) {
        this.connectedServerVersionString = versionString;
        this.connectedServerVersion = BuildMetadata_1.BuildMetadata.calculateVersion(versionString);
    };
    ClientConnection.prototype.getConnectedServerVersion = function () {
        return this.connectedServerVersion;
    };
    /**
     * Closes this connection.
     */
    ClientConnection.prototype.close = function () {
        this.socket.end();
        this.closedTime = Date.now();
    };
    ClientConnection.prototype.isAlive = function () {
        return this.closedTime === 0;
    };
    ClientConnection.prototype.isAuthenticatedAsOwner = function () {
        return this.authenticatedAsOwner;
    };
    ClientConnection.prototype.setAuthneticatedAsOwner = function (asOwner) {
        this.authenticatedAsOwner = asOwner;
    };
    ClientConnection.prototype.toString = function () {
        return this.address.toString();
    };
    /**
     * Registers a function to pass received data on 'data' events on this connection.
     * @param callback
     */
    ClientConnection.prototype.registerResponseCallback = function (callback) {
        var _this = this;
        this.socket.on('data', function (buffer) {
            _this.lastRead = new Date().getTime();
            _this.readBuffer = Buffer.concat([_this.readBuffer, buffer], _this.readBuffer.length + buffer.length);
            while (_this.readBuffer.length >= BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES) {
                var frameSize = _this.readBuffer.readInt32LE(0);
                if (frameSize > _this.readBuffer.length) {
                    return;
                }
                var message = new Buffer(frameSize);
                _this.readBuffer.copy(message, 0, 0, frameSize);
                _this.readBuffer = _this.readBuffer.slice(frameSize);
                callback(message);
            }
        });
    };
    return ClientConnection;
}());
exports.ClientConnection = ClientConnection;
//# sourceMappingURL=ClientConnection.js.map