"use strict";
/*
 * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Address = require("./Address");
var TopicOverloadPolicy_1 = require("./proxy/topic/TopicOverloadPolicy");
var DEFAULT_GROUP_NAME = 'dev';
var DEFAULT_GROUP_PASSWORD = 'dev-pass';
/**
 * Group configuration of the cluster that this client connects.
 * A client will connect to only the cluster with these properties.
 */
var GroupConfig = /** @class */ (function () {
    function GroupConfig() {
        /**
         * Cluster group name.
         */
        this.name = DEFAULT_GROUP_NAME;
        /**
         * Cluster group password.
         */
        this.password = DEFAULT_GROUP_PASSWORD;
    }
    return GroupConfig;
}());
exports.GroupConfig = GroupConfig;
var SocketOptions = /** @class */ (function () {
    function SocketOptions() {
    }
    return SocketOptions;
}());
exports.SocketOptions = SocketOptions;
/**
 * Network configuration
 */
var ClientNetworkConfig = /** @class */ (function () {
    function ClientNetworkConfig() {
        /**
         * While client is trying to connect initially to one of the members in the {@link addresses},
         * all might be not available. Instead of giving up, throwing Exception and stopping client, it will
         * attempt to retry as much as {@link connectionAttemptLimit} times.
         */
        this.connectionAttemptLimit = 2;
        /**
         * Period for the next attempt to find a member to connect.
         */
        this.connectionAttemptPeriod = 3000;
        /**
         * Timeout value in millis for nodes to accept client connection requests.
         */
        this.connectionTimeout = 5000;
        /**
         * true if redo operations are enabled (not implemented yet)
         */
        this.redoOperation = false;
        /**
         * If true, client will behave as smart client instead of dummy client. Smart client sends key based operations
         * to owner of the keys. Dummy client sends all operations to a single node. See http://docs.hazelcast.org to
         * learn about smart/dummy client.
         */
        this.smartRouting = true;
        /**
         * Not implemented.
         */
        this.socketOptions = new SocketOptions();
        /**
         * sslOptions is by default null which disables Ssl. A none null {@link SSLOptions} value enables Ssl.
         * @type {SSLOptions}
         */
        this.sslOptions = null;
        this.addresses = [
            new Address('localhost', 5701)
        ];
    }
    return ClientNetworkConfig;
}());
exports.ClientNetworkConfig = ClientNetworkConfig;
var SerializationConfig = /** @class */ (function () {
    function SerializationConfig() {
        this.defaultNumberType = 'double';
        this.isBigEndian = true;
        this.dataSerializableFactories = {};
        this.portableFactories = {};
        this.portableVersion = 0;
        this.customSerializers = [];
        this.globalSerializer = null;
    }
    return SerializationConfig;
}());
exports.SerializationConfig = SerializationConfig;
var ReliableTopicConfig = /** @class */ (function () {
    function ReliableTopicConfig() {
        this.readBatchSize = 25;
        this.overloadPolicy = TopicOverloadPolicy_1.TopicOverloadPolicy.BLOCK;
    }
    return ReliableTopicConfig;
}());
exports.ReliableTopicConfig = ReliableTopicConfig;
var GlobalSerializerConfig = /** @class */ (function () {
    function GlobalSerializerConfig() {
    }
    return GlobalSerializerConfig;
}());
exports.GlobalSerializerConfig = GlobalSerializerConfig;
/**
 * Represents the format that objects are kept in this client's memory.
 */
var InMemoryFormat;
(function (InMemoryFormat) {
    /**
     * Objects are in native JS objects
     */
    InMemoryFormat[InMemoryFormat["OBJECT"] = 0] = "OBJECT";
    /**
     * Objects are in serialized form
     */
    InMemoryFormat[InMemoryFormat["BINARY"] = 1] = "BINARY";
})(InMemoryFormat = exports.InMemoryFormat || (exports.InMemoryFormat = {}));
var EvictionPolicy;
(function (EvictionPolicy) {
    EvictionPolicy[EvictionPolicy["NONE"] = 0] = "NONE";
    EvictionPolicy[EvictionPolicy["LRU"] = 1] = "LRU";
    EvictionPolicy[EvictionPolicy["LFU"] = 2] = "LFU";
    EvictionPolicy[EvictionPolicy["RANDOM"] = 3] = "RANDOM";
})(EvictionPolicy = exports.EvictionPolicy || (exports.EvictionPolicy = {}));
var NearCacheConfig = /** @class */ (function () {
    function NearCacheConfig() {
        this.name = 'default';
        /**
         * 'true' to invalidate entries when they are changed in cluster,
         * 'false' to invalidate entries only when they are accessed.
         */
        this.invalidateOnChange = true;
        /**
         * Max number of seconds that an entry can stay in the cache until it is acceessed
         */
        this.maxIdleSeconds = 0;
        this.inMemoryFormat = InMemoryFormat.BINARY;
        /**
         * Maximum number of seconds that an entry can stay in cache.
         */
        this.timeToLiveSeconds = 0;
        this.evictionPolicy = EvictionPolicy.NONE;
        this.evictionMaxSize = Number.MAX_SAFE_INTEGER;
        this.evictionSamplingCount = 8;
        this.evictionSamplingPoolSize = 16;
    }
    NearCacheConfig.prototype.toString = function () {
        return 'NearCacheConfig[' +
            'name: ' + this.name + ', ' +
            'invalidateOnChange:' + this.invalidateOnChange + ', ' +
            'inMemoryFormat: ' + this.inMemoryFormat + ', ' +
            'ttl(sec): ' + this.timeToLiveSeconds + ', ' +
            'evictionPolicy: ' + this.evictionPolicy + ', ' +
            'evictionMaxSize: ' + this.evictionMaxSize + ', ' +
            'maxIdleSeconds: ' + this.maxIdleSeconds + ']';
    };
    return NearCacheConfig;
}());
exports.NearCacheConfig = NearCacheConfig;
/**
 * Configurations for LifecycleListeners. These are registered as soon as client started.
 */
var ListenerConfig = /** @class */ (function () {
    function ListenerConfig() {
        this.lifecycle = [];
    }
    ListenerConfig.prototype.addLifecycleListener = function (listener) {
        this.lifecycle.push(listener);
    };
    ListenerConfig.prototype.getLifecycleListeners = function () {
        return this.lifecycle;
    };
    return ListenerConfig;
}());
exports.ListenerConfig = ListenerConfig;
/**
 * Top level configuration object of Hazelcast client. Other configurations items are properties of this object.
 */
var ClientConfig = /** @class */ (function () {
    function ClientConfig() {
        this.properties = {
            'hazelcast.client.heartbeat.interval': 5000,
            'hazelcast.client.heartbeat.timeout': 60000,
            'hazelcast.client.invocation.retry.pause.millis': 1000,
            'hazelcast.client.invocation.timeout.millis': 120000,
            'hazelcast.invalidation.reconciliation.interval.seconds': 60,
            'hazelcast.invalidation.max.tolerated.miss.count': 10,
            'hazelcast.invalidation.min.reconciliation.interval.seconds': 30
        };
        this.groupConfig = new GroupConfig();
        this.networkConfig = new ClientNetworkConfig();
        this.customCredentials = null;
        this.listeners = new ListenerConfig();
        this.serializationConfig = new SerializationConfig();
        this.reliableTopicConfigs = {
            'default': new ReliableTopicConfig()
        };
        this.nearCacheConfigs = {};
    }
    return ClientConfig;
}());
exports.ClientConfig = ClientConfig;
//# sourceMappingURL=Config.js.map